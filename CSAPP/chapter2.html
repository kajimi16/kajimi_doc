<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>信息的表示和处理 - KAJIMI_BOOK</title>


    <!-- Custom HTML head -->

    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff">

    <link rel="icon" href="../favicon.svg">
    <link rel="shortcut icon" href="../favicon.png">
    <link rel="stylesheet" href="../css/variables.css">
    <link rel="stylesheet" href="../css/general.css">
    <link rel="stylesheet" href="../css/chrome.css">
    <link rel="stylesheet" href="../css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="../fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="../highlight.css">
    <link rel="stylesheet" href="../tomorrow-night.css">
    <link rel="stylesheet" href="../ayu-highlight.css">

    <!-- Custom theme stylesheets -->


    <!-- Provide site root to javascript -->
    <script>
        var path_to_root = "../";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
    </script>
    <!-- Start loading toc.js asap -->
    <script src="../toc.js"></script>
</head>

<body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor"
                            title="Toggle Table of Contents" aria-label="Toggle Table of Contents"
                            aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                            aria-label="Change theme" aria-haspopup="true" aria-expanded="false"
                            aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">KAJIMI_BOOK</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                            aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="第二章-信息的表示和处理"><a class="header" href="#第二章-信息的表示和处理">第二章 信息的表示和处理</a></h1>
<p>你知道的，前面还是些小菜，现在卡基米确实看得有些糊涂了。
这一章的主要内容在我看来，是<strong>打破传统数字的概念，理解计算机上面的数字，建立新的“直觉”</strong>，正是因为计算机里面的数字和自然状态的数字不一样，会在程序中产生不一样的行为，了解这些细节对于一口气写出正常的程序非常重要（或者及时补救说是）
闲话少说，直接开始折磨</p>
<h3 id="21-信息存储"><a class="header" href="#21-信息存储">2.1 信息存储</a></h3>
<h4 id="211-十六进制表示法"><a class="header" href="#211-十六进制表示法">2.1.1 十六进制表示法</a></h4>
<p>由于计算机一个字节8个位，直接写一串01有一点神秘，所以我们可以用十六进制把4个位压成一个数字，这样一共有16个数字，0-9，A-F，用A-F表示10-15。用0x来说明这是个十六进制数。
比如二进制数11110000可以被压缩成0xF0
只需要</p>
<ul>
<li>2-&gt;16：划分为4个4个一组，开头不足的补0，进行转换</li>
<li>16-&gt;2：一变四（可以记住对应十进制数，然后化成对应4个二进制数）</li>
</ul>
<h4 id="213-字数据大小"><a class="header" href="#213-字数据大小">2.1.3 字数据大小</a></h4>
<p>不知道安装应用有没有看到x86，x64之类的字母，这些都是什么意思呢？<br />
实际上，这里说的是计算机的字长，它决定了虚拟地址空间的最大大小，现在我们一般用的64位的设备。总之可以看成你设备的内存可以用多长的地址来表示。<br />
那么我们不禁发问了，设备的字长不一样，我们的程序怎么保证同一变量在不同设备都正常存储呢？
答案是，我们需要做到<strong>可移植性</strong>，比如c语言里就有<code>int32_t</code>之类指定它的数据大小。</p>
<h4 id="213-寻址和字节顺序"><a class="header" href="#213-寻址和字节顺序">2.1.3 寻址和字节顺序</a></h4>
<p>由于一个对象可能要用好几个字节，我们通常把它存储为连续的字节序列，用第一个地址表示它的地址，但是只能放这一长串就有两种</p>
<ul>
<li>大端法：最高有效位在前面，比如0x12345678，从低到高会存12 34 56 78</li>
<li>小端法：最低有效位在前面，比如0x12345678，从低到高会存78 56 34 12</li>
</ul>
<p>两种方法没什么区别，纯粹大家习惯不同，结果都不想改，最后导致不同设备读取对方的数据发生了问题（因为顺序不同，结果拿到了反序的数据）</p>
<h4 id="214-表示字符串"><a class="header" href="#214-表示字符串">2.1.4 表示字符串</a></h4>
<p>相反，如果是一堆char，因为它就用一字节，而且都用ASCLL码表示，所以跨平台更不容易出问题。</p>
<h4 id="215-表示代码"><a class="header" href="#215-表示代码">2.1.5 表示代码</a></h4>
<p>这里告诉我们二进制代码在不同操作系统上面是不兼容的</p>
<h4 id="216-布尔代数简介"><a class="header" href="#216-布尔代数简介">2.1.6 布尔代数简介</a></h4>
<p>这里终于到了我们神神秘秘的布尔代数了，下面是四个常用的布尔运算，对接下来的位级运算很<strong>有用</strong></p>
<ul>
<li><strong>与</strong>A是1，B是1，则A&amp;B=1</li>
<li><strong>或</strong>A是1或者B是1，则A|B=1</li>
<li><strong>非</strong>A是1，则~A=0，A是0，则~A=1</li>
<li><strong>异或</strong>A和B都是1或者0，则A^B=0，A和B不同，则A^B=1</li>
</ul>
<p>现在你已经会了运算方法了，我们就可以对位向量（一堆1和0的序列）进行运算了。
比如</p>
<ul>
<li>1010&amp;1111=1010</li>
<li>1000|0101=1101</li>
<li>1010^1100=0110</li>
<li>~1010=0101</li>
</ul>
<p>位向量可以解决很多问题，比如把集合{0，1，3}表示为1101，{1，2}表示为0110，那么1101&amp;0110=0100，说明两个集合有2这个共同元素。</p>
<h4 id="217-c语言中的位级运算"><a class="header" href="#217-c语言中的位级运算">2.1.7 C语言中的位级运算</a></h4>
<p>这里主要说明上面的这些计算方法刚好C语言都能用，通过熟练掌握这些东西，我们可以实现一些行为，比如掩码计算（以后再说）</p>
<h4 id="218-c语言中的逻辑运算"><a class="header" href="#218-c语言中的逻辑运算">2.1.8 C语言中的逻辑运算</a></h4>
<p>C语言中有以下3种逻辑运算符</p>
<ul>
<li>&amp;&amp;（与）</li>
<li>||（或）</li>
<li>！（非）</li>
</ul>
<p>它们不对参数进行按位计算一大串01，而是把参数当成0和1，只要不是0，剩下的1234，1.0，都当成TRUE，0，NULL，空字符串，都当成FALSE。</p>
<h4 id="219-c语言中的移位运算"><a class="header" href="#219-c语言中的移位运算">2.1.9 C语言中的移位运算</a></h4>
<ul>
<li><code>&lt;&lt;</code>（左移）</li>
<li><code>&gt;&gt;</code>（右移）</li>
</ul>
<p>左移很简单，就是把每个位向高移动对应位数，超出最高位的丢弃，在低位补0。比如（0101）&lt;&lt;1 = 1010，（1010）&lt;&lt;2 = 1000
右移就有两种可能了，出于后面会说的特殊需求有算术右移和逻辑右移两种。
两种右移都是向地位移动指定位数，超过最低位的丢弃。
但是算术右移会按照开始时是1就在高位补1，如果是0就和逻辑右移一样在高位补0。</p>
<p>有一个有趣的点是，如果你把一个32位的东西移动了36位，C程序可能只会移动4位，因为它对移动的位数进行了取模。（不过说不准）</p>
<h3 id="22-整数表示"><a class="header" href="#22-整数表示">2.2 整数表示</a></h3>
<p><strong>接下来大的要来了</strong></p>
<h4 id="221整型数据类型"><a class="header" href="#221整型数据类型">2.2.1整型数据类型</a></h4>
<p>只需要知道</p>
<ul>
<li>不同变量字节数不同，所以取值范围不同</li>
<li>整型分为有符号和无符号</li>
<li>有符号由于表示方式，负数的取值范围比正数大一</li>
</ul>
<h4 id="222-无符号数的编码"><a class="header" href="#222-无符号数的编码">2.2.2 无符号数的编码</a></h4>
<p>按照从最低位是2的0次方，从低到高不断递增1，实现把一个无符号的数变成一条位向量比如15等于2的3次方加2次方加2的1次方加2的零次方，所以15的位向量就是1111。</p>
<h4 id="223-补码编码"><a class="header" href="#223-补码编码">2.2.3 补码编码</a></h4>
<p>这里特别的地方就是把最高有效位的权重改成<code>-2^{最高位的位数-1}</code>，现在就可以用同样的一串位向量表示负数了，实现了有符号。
举例说明：</p>
<ul>
<li>0101：<code>2^2+2^0=4+1=5</code></li>
<li>1010: <code>-2^3+2^1=-8+2=-6</code></li>
</ul>
<p>通过这种刚开始看可能有点怪的编码方法，我们实现了有符号数的表示。
现在可以解答为什么有符号的数负的取值范围比正数大一。
因为1开头表达-8到-1,0开头却表达0-7，被0占用了1个取值范围说是。</p>
<p>如果上过我们24的程序设计课，我们还知道有其他的表达方式</p>
<ul>
<li>原码 第一位表示正负号，剩下的位表示数值，比如0001表示1，1001表示-1（可能这种方式更好理解）</li>
<li>反码 正数的反码就是它原码本身，负数的反码是它的符号位除外，其余位取反，比如1010=1101。这种方式，我们可以得到第一位表示<code>-(2^{最高位的位数-1}-1)</code>剩下表示<code>2^{对应位数-1}</code>,比如<code>1010 = -(2^3-1)+2^1=-7+2=-5</code>(注意力够好的小伙伴可以发现，把1010加1就是1011，而这刚好是-5的补码编码)</li>
</ul>
<h4 id="224-有符号数和无符号数之间的转换"><a class="header" href="#224-有符号数和无符号数之间的转换">2.2.4 有符号数和无符号数之间的转换</a></h4>
<p>有人说，<strong>C语言有强制类型转换和指针，这是最好的特性，也是最坏的特性</strong>,总之，学了这里，你不至于在无符号和有符号强转的时候出错</p>
<p>简而言之，底层的逻辑其实是变成位向量，然后换对方的编码方式，比如对于字长4位的机器，无符号的9转成1001,再按照补码编码变成-7，就是这个逻辑。
而为了快速计算，我们可以这么想，无符号变有符号，第一位从+2的(最高位-1)次方变成-2的(最高位-1)次方了，那我们就可以-2个2的(最高位-1)次方。（<code>9 - 2*(2^(4-1))= -7</code>
同理，有符号变成无符号就是把第一个位从-2的(最高位-1)次方变成2的(最高位-1)次方，，我们可以直接加两个2的(最高位-1)次方。
总结就是<strong>第一次抵消原本编码方式的影响，第二次采用新的表达方式</strong>。</p>
<h4 id="225-c语言中的有符号数和无符号数"><a class="header" href="#225-c语言中的有符号数和无符号数">2.2.5 C语言中的有符号数和无符号数</a></h4>
<p>这里我们需要知道的只有C语言表达式的变量只要有一个无符号的，就会把所有有符号数变成无符号的，然后进行运算，需要小心神秘的行为比如 -1被认为大于0（无符号）</p>
<h4 id="226-扩展一个数字的位表示"><a class="header" href="#226-扩展一个数字的位表示">2.2.6 扩展一个数字的位表示</a></h4>
<p>你看，现在我们知道为什么右移有两种方式了，算术右移和逻辑右移。
无符号数只要不断创建新的最高位再用0填充
有符号数就看第一个是什么，1就不断补1，0就不断补0。</p>
<p>举例说明：补码编码1001加上新的最高位1后原本第四位的1从-8变成了8，而新加的1变成了-16，两个抵消一下相当于-8，数的值就可以不变，而拓展位表示。</p>
<h4 id="227-截断数字"><a class="header" href="#227-截断数字">2.2.7 截断数字</a></h4>
<p>截断也很简单，底层就是直接丢掉对应的高位
而表面上的数，无符号可以简单的取（最高位的2次方）的模
有符号没有简单的办法，只能先变成无符号，取模完变回有符号。</p>
<h4 id="228-关于有符号数与无符号数的建议"><a class="header" href="#228-关于有符号数与无符号数的建议">2.2.8 关于有符号数与无符号数的建议</a></h4>
<p>建议你多练说是（x</p>
<h3 id="23-整数运算"><a class="header" href="#23-整数运算">2.3 整数运算</a></h3>
<h4 id="231-无符号加法"><a class="header" href="#231-无符号加法">2.3.1 无符号加法</a></h4>
<p>底层就是直接进行按位加，然后溢出就截断。
表面上看变成了一个滚轮，到了能表达的最大值，比如15，再加1就变成0了
要检测也很简单，只要看加法结果是不是反而比原来小就行</p>
<h4 id="232-补码加法"><a class="header" href="#232-补码加法">2.3.2 补码加法</a></h4>
<p>老规矩，底层就是变成位级表示，然后按位加，多了截断
表面上看就是一个滚轮，但是到了最大值，再加1就变成最小值了
怎么算呢，如果小于最小值，就加一个2的字节数次方，大于最大值，就减一个2的字节数次方。<br />
要检测有没有爆，看正正相加有没有变成负，负负相加有没有变成正</p>
<h4 id="233-补码的非"><a class="header" href="#233-补码的非">2.3.3 补码的非</a></h4>
<p>在2.3.1中，提到了阿贝尔群，意思是模数加法形成了阿贝尔群，它具有可交换和可结合性，就是说虽然行为怪怪的，但是有符号和无符号数的运算是符合交换律和结合率的。
这里我们就定义补码的非就是和自身相加等于0的数。
为了实现它，其实就是想办法让按位加溢出。截断后剩下一条0.
这里底层反而比表面难，表面只要对不是最小值的取负数，对于最小值取本身就行。
底层可以按位非然后+1，或者找到最低位的1把左边全部按位非</p>
<h4 id="234-无符号乘法"><a class="header" href="#234-无符号乘法">2.3.4 无符号乘法</a></h4>
<p>进行一个x*y然后取模，和加法一样，这里没讲怎么直接实现按位乘法，有点好奇。</p>
<h4 id="235-补码乘法"><a class="header" href="#235-补码乘法">2.3.5 补码乘法</a></h4>
<p>位级等价性不是很懂，按照我的理解，就是换成无符号数进行乘法，再把结果换回有符号数没有影响。
因为本质上都是变成按位乘法，然后再得到一样的位向量（截断后），只是按照不懂编码方式变回十进制数说是。</p>
<h4 id="236-乘以常数"><a class="header" href="#236-乘以常数">2.3.6 乘以常数</a></h4>
<p>你知道的，乘法一看就比加法耗时间，我们能不能把乘法变成比较快的操作呢？
众所周知，一个常数可以变成二进制，这说明它可以拆成一堆2的不同次幂的和。而对于一个数，乘以2的幂，不就是把它左移吗（
所以我们可以进行如下的操作
比如<code>x * 7 = x &lt;&lt; 2 + x &lt;&lt; 1  + x</code>
当然我们还可以贪
<code>x * 7 = x &lt;&lt; 3 - x</code>
具体怎么贪看哪个方法耗时短，设备会替你考虑的</p>
<h4 id="237-除以2的幂"><a class="header" href="#237-除以2的幂">2.3.7 除以2的幂</a></h4>
<p>为了实现向0的方向取整，（-1.1-&gt;-1, 1.1-&gt;1）这里有符号的会比较复杂。
无符号和有符号的正值只需要大胆的右移。因为移位的行为舍去了多余的低位，相当于向下取整。
而有符号的负值就麻烦了，因为右移是向下取整，但我们需要向上取整，怎么办呢？
我们可以用偏置技术，按照位移的位数，给负数加上（2的位移位数次方-1），再进行右移。
为什么，这样可以对于被截断的位数进行一个隐形的判断，但凡被截断的地方有一点值，就会向刚好没被截断的最低位+1，这样就会向上取整，而如果刚好被整除，也不会产生干扰，因为这个偏量刚好被截断了</p>
<h4 id="238-关于整数运算最后的思考"><a class="header" href="#238-关于整数运算最后的思考">2.3.8 关于整数运算最后的思考</a></h4>
<p>总之，要记住关键就是<strong>变成二进制，完成位级运算，再编码回所需形式</strong></p>
<h3 id="24-浮点数"><a class="header" href="#24-浮点数">2.4 浮点数</a></h3>
<p>一直在说我们的整型，那我们的浮点数肯定要发言了。
当然，还是从简单的开始</p>
<h4 id="241-二进制小数"><a class="header" href="#241-二进制小数">2.4.1 二进制小数</a></h4>
<p>如果小数点左边是2的n次方，那小数点右边也不能搞特殊，所以，小数点右边就是负次方说是，第一个二分之一，第二个四分之一以此类推。
我们可以发现这样没办法精确表示一些小数，实际上本来就是这样，小数就是只能在计算机里面无限接近，近似表达的（10进制不也有无限不循环小数吗，也是只能近似表达）</p>
<h4 id="242-ieee浮点表示"><a class="header" href="#242-ieee浮点表示">2.4.2 IEEE浮点表示</a></h4>
<p>可以发现，如果浮点还是和整型换汤不换药，不是很理想
于是我们有了IEEE754标准
它把浮点数分成三部分：符号位、阶码字段、尾数字段</p>
<ul>
<li>符号位：最前，0表示正数，1表示负数</li>
<li>阶码字段：中间，阶码（对尾数表示的小数乘以2的几次方），这不就是在说小数点位置应该在哪里吗，实际上就是这样，所以用了生动形象的比喻，<strong>浮</strong>点</li>
<li>尾数字段：最后，表示小数部分，表示在按照指数字段表示的数移位之前的基数</li>
</ul>
<p>所以浮点数就是<code>浮点数 = (-1)^{符号位} *尾数*2^{阶码} </code>
单精度浮点阶码字段8位，尾数字段23位
双精度浮点阶码字段11位，尾数字段52位
虽然看起来已经结束了，但是根据字段内容的不同，解读被编码的值的规则是不一样的
分三种情况：</p>
<ul>
<li>规格化的
<ul>
<li>表现：阶码字段既不全为0也不全为1</li>
<li>阶码字段 = 阶码字段直接转10进制 - 2的（阶码字段长度 -1）次方 + 1
这么做是为了实现负次方的幂</li>
<li>尾数字段 = 尾数字段直接转10进制 + 1
这么做是为了实现省略小数点前面的0，因为反正这种情况下都是一，不如贪一位，让尾数更精确</li>
</ul>
</li>
<li>非规格化的
<ul>
<li>表现：阶码字段全为0</li>
<li>阶码字段 = - 2的（阶码字段长度 -1）次方 + 1
这么做是为了实现和规格化平滑切换</li>
<li>尾数字段 = 尾数字段直接转10进制
因为这时候表达的数非常接近0或者就是0，搞不到1说是</li>
</ul>
</li>
<li>无穷大或者NaN
<ul>
<li>表现：阶码字段全为1</li>
<li>尾数字段不全为0 NaN（Not a Number）</li>
<li>尾数字段全为0 Inf（无穷大）</li>
</ul>
</li>
</ul>
<h4 id="243-数字实例"><a class="header" href="#243-数字实例">2.4.3 数字实例</a></h4>
<p>这里假定一个8位浮点，有4个阶码位和3个尾数位
<strong>0 0000 001</strong></p>
<ul>
<li>首先看到它是非规格化的，经过计算公式，我们知道它的阶码为<code>1-2^{4-1}=-6</code>尾数为0.001（二进制）</li>
<li>经过向左移动小数点6位，得到0.000 000 001（二进制）</li>
<li>所以这个数是1/512
<strong>0 0111 110</strong></li>
<li>首先看到它是规格化的，经过计算公式，我们知道它的阶码为<code>14 - 2^{4-1}+1 =7</code>尾数为1.110（二进制）</li>
<li>经过向左、右移动小数点7位，得到1110 0000.0（二进制）</li>
<li>所以这个数是 224.0</li>
</ul>
<h4 id="244-舍入"><a class="header" href="#244-舍入">2.4.4 舍入</a></h4>
<p>通常我们有四种舍入方式</p>
<ul>
<li>向零舍入</li>
<li>向上舍入</li>
<li>向下舍入</li>
<li>以及全新的向偶数舍入</li>
</ul>
<p>我们肯定是讨论新鲜的东西，什么是向偶数舍入呢？
对于一长串的二进制，舍入到指定位数，我们看它偏向向上舍入还是舍下舍入，如果发现两种方法都一样就选能让最低有效位是0的那个
这样有什么好处呢，其实就是说，一直四舍五入数据偏大，一直五舍六入数据偏小，如果选择在五的时候向偶数方向舍入，就也可以总体上50%概率五舍，50%五入</p>
<h4 id="245-浮点运算"><a class="header" href="#245-浮点运算">2.4.5 浮点运算</a></h4>
<p>这里没有讲底层的实现，只要知道由于舍入的性质，浮点运算可以交换，但不能结合</p>
<h4 id="246-c语言中的浮点数"><a class="header" href="#246-c语言中的浮点数">2.4.6 C语言中的浮点数</a></h4>
<p>这里需要明确</p>
<ul>
<li>int -&gt; float 数字不会溢出，但可能会被舍入</li>
<li>double -&gt; float 数字可能会溢出,也可能会被舍入</li>
<li>int/float -&gt; double 数字不会溢出，也不会被舍入</li>
<li>float/double -&gt; int 数字会被向0舍入,接着可能发生溢出</li>
</ul>
<h3 id="25-小结"><a class="header" href="#25-小结">2.5 小结</a></h3>
<p>不想说话了，这章内容确实一大堆，我已经尽可能去提供一些自己的理解方式了</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <a rel="prev" href="../CSAPP/chapter1.html" class="mobile-nav-chapters previous"
                            title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                            <i class="fa fa-angle-left"></i>
                        </a>

                        <a rel="next prefetch" href="../Top-Down_Approach/Chapter0.html" class="mobile-nav-chapters next"
                            title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                            <i class="fa fa-angle-right"></i>
                        </a>

                        <div style="clear: both"></div>
                    </nav>
                    <main>
                        <hr>
                        <div id="giscus-container"></div>
                    </main>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                <a rel="prev" href="../CSAPP/chapter1.html" class="nav-chapters previous" title="Previous chapter"
                    aria-label="Previous chapter" aria-keyshortcuts="Left">
                    <i class="fa fa-angle-left"></i>
                </a>

                <a rel="next prefetch" href="../Top-Down_Approach/Chapter0.html" class="nav-chapters next" title="Next chapter"
                    aria-label="Next chapter" aria-keyshortcuts="Right">
                    <i class="fa fa-angle-right"></i>
                </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/giscus.js"></script>


    </div>
</body>

</html>